"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Battlefield = void 0;
const Rcon_1 = require("./transport/Rcon");
const crypto_1 = require("crypto");
const events_1 = require("events");
const Variable_1 = require("./Variable");
class Battlefield extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.pbAddressCache = {};
        this.version = {
            game: Battlefield.Version.UNKNOWN,
            version: 0
        };
        this.options = options;
        this.rcon = new Rcon_1.Rcon({
            ...this.options,
            eventHandler: this.eventHandler.bind(this)
        });
        this.var = new Variable_1.Variable(this.rcon, "vars");
        this.vu = new Variable_1.Variable(this.rcon, "vu");
        if (this.options.autoconnect !== false)
            this.rcon.connect();
        this.rcon.on("error", err => this.rconError = err);
        this.rcon.on("close", () => this.emit("close", this.rconError));
    }
    /**
     * tests an rcon connection and disconnects after
     */
    static async testConnection(options) {
        let bf3;
        try {
            bf3 = await Battlefield.connect(options);
            bf3.quit();
            return true;
        }
        catch (e) {
            return e;
        }
    }
    /**
     * creates a new Battlefield instance
     * @param options
     */
    static async connect(options) {
        const bf3 = new Battlefield({ ...options, autoconnect: false });
        return bf3.connect();
    }
    /** connects and initializes the query */
    async connect() {
        await this.rcon.connect();
        try {
            return this.initialize();
        }
        catch (e) {
            this.rcon.stop();
            throw e;
        }
    }
    /** initializes the connection */
    async initialize() {
        await this.fetchVersion();
        await this.login(this.options.password);
        await this.enableEvents(true);
        this.emit("ready");
        return this;
    }
    /**
     * sleeps a certain time
     * @param time
     */
    static sleep(time) {
        return new Promise(fulfill => {
            setTimeout(fulfill, time);
        });
    }
    /**
     * attempts to reconnects to the battlefield server
     * @param maxAttempts number of tries <= 0 tries to connect forever
     * @param timeout timeout in ms between connection attempts
     */
    async reconnect(maxAttempts = -1, timeout = 1000) {
        let attempts = 0;
        while (attempts++ < maxAttempts || maxAttempts <= 0) {
            await Battlefield.sleep(timeout);
            try {
                await this.connect();
                return this;
            }
            catch (e) {
                console.log(`reconnect attempt #${attempts} failed`, e);
            }
        }
        throw new Error(`could not reconnect after ${maxAttempts} tries`);
    }
    eventHandler(event, words) {
        if (event.startsWith("punkBuster."))
            return this.onPunkBuster(event, words);
        switch (event) {
            case "player.onChat": return this.playerOnChat(words);
            case "player.onSpawn": return this.playerOnSpawn(words);
            case "player.onKill": return this.playerOnKill(words);
            case "player.onJoin": return this.onJoin(words);
            case "player.onSquadChange": return this.onSquadChange(words);
            case "player.onTeamChange": return this.onTeamChange(words);
            case "player.onAuthenticated": return this.onAuthenticated(words);
            case "player.onLeave": return this.playerOnLeave(words);
            case "server.onMaxPlayerCountChange": return this.onMaxPlayerCountChange(words);
            case "server.onLevelLoaded": return this.onLevelLoaded(words);
            case "server.onRoundOver": return this.onRoundOver(words);
            case "server.onRoundOverPlayers": return this.onRoundOverPlayers(words);
            case "server.onRoundOverTeamScores": return this.onRoundOverTeamScores(words);
            default:
                this.emit("event", { event, words });
        }
    }
    onRoundOverTeamScores(words) {
        this.emit("roundOverTeamScores", this.getScores(words));
    }
    onRoundOverPlayers(words) {
        this.emit("roundOverPlayers", { players: this.parseClientList()(words) });
    }
    onRoundOver(words) {
        this.emit("roundOver", { winner: words[0].toNumber() });
    }
    onLevelLoaded(words) {
        this.emit("levelLoaded", {
            map: words[0].toString(),
            mode: words[1].toString(),
            roundsPlayed: words[2].toNumber(),
            roundsTotal: words[3].toNumber()
        });
    }
    onMaxPlayerCountChange(words) {
        this.emit("maxPlayerCountChange", { maxPlayerCount: words[0].toNumber() });
    }
    playerOnLeave(words) {
        const players = this.parseClientList()(words.slice(1));
        players.forEach(player => {
            const ip = this.pbAddressCache[player.name];
            if (ip) {
                player.ip = ip;
                delete this.pbAddressCache[player.name];
            }
            this.emit("playerLeave", { player });
        });
    }
    onSquadChange(words) {
        const name = words[0].toString();
        const player = this.getPlayerByName(name);
        if (!player)
            throw new Error(`could not find player ${name} in event player.onSquadChange`);
        this.emit("squadChange", {
            player,
            team: words[1].toNumber(),
            squad: words[2].toNumber(),
        });
    }
    onTeamChange(words) {
        const name = words[0].toString();
        const player = this.getPlayerByName(name);
        if (!player)
            throw new Error(`could not find player ${name} in event player.onSquadChange`);
        this.emit("teamChange", {
            player,
            team: words[1].toNumber(),
            squad: words[2].toNumber(),
        });
    }
    async onAuthenticated(words) {
        this.emit("playerAuthenticated", { name: words[0].toString() });
    }
    async onJoin(words) {
        this.emit("playerJoin", { name: words[0].toString(), guid: words[1].toString() });
    }
    onPunkBuster(event, words) {
        event = event.split(".").slice(1).join(".");
        const messages = words.map(w => w.toString());
        messages.forEach(msg => {
            const regex = /PunkBuster Server: New Connection \(slot #\d+\) (.*):(\d+) \[.*\] "(.*)" \(.*\)/;
            const match = msg.match(regex);
            if (!match)
                return;
            this.pbAddressCache[match[3]] = match[1];
        });
        this.emit("punkbuster", { event, messages });
    }
    async playerOnKill(words) {
        this.emit("kill", {
            killer: words[0].toString(),
            killed: words[1].toString(),
            weapon: words[2].toString(),
            headshot: words[3].toBoolean()
        });
    }
    async playerOnSpawn(words) {
        const player = await this.getPlayerByName(words[0].toString());
        if (!player)
            throw new Error(`could not find player with name ${name} in event player.onSpawn`);
        this.emit("spawn", { player, team: words[1].toString() });
    }
    async playerOnChat(words) {
        const event = {
            player: words[0].toString(),
            msg: words[1].toString(),
            subset: words[2].toString()
        };
        if (event.subset === "team") {
            event.team = words[3].toNumber();
        }
        else if (event.subset === "squad") {
            event.team = words[3].toNumber();
            event.squad = words[4].toNumber();
        }
        this.emit("chat", event);
    }
    createCommand(cmd, ...args) {
        const request = this.rcon.createCommand(cmd, ...args);
        this.emit("request", { request });
        return request;
    }
    /** sends the help command to the server */
    help() {
        return this.createCommand("admin.help").send();
    }
    /**
     * Set whether or not the server will send events to the current connection
     * @param set enable or disable events
     */
    enableEvents(set) {
        return this.createCommand("admin.eventsEnabled", set).send();
    }
    /** Game server type and build ID uniquely identify the server, and the protocol it is running. */
    fetchVersion() {
        return this.createCommand("version")
            .format(w => ({ game: w[0].toString(), version: w[1].toNumber() })).send()
            .then(({ version, game }) => {
            this.version = (() => {
                switch (game) {
                    case "BF3":
                        return { game, version };
                    default:
                        throw new Error(`unsupported game ${version}`);
                }
            })();
            return this.version;
        });
    }
    /** get the battlefield server salt */
    getSalt() {
        return this.createCommand("login.hashed")
            .priorize()
            .format(w => Buffer.from(w[0].toString(), "hex"))
            .send();
    }
    /** creates the hashed password from the actual password and the hash */
    getPasswordHash(password, hash) {
        return crypto_1.createHash("md5")
            .update(hash)
            .update(password)
            .digest("hex")
            .toUpperCase();
    }
    /**
     * Securely logs you in with a hashed password
     * @param password password to login with
     */
    async login(password) {
        return this.rcon
            .createCommand("login.hashed", this.getPasswordHash(password, await this.getSalt()))
            .priorize()
            .send();
    }
    /** Logout from game server */
    logout() {
        return this.createCommand("logout").send();
    }
    /** return list of all players on the server, but with zeroed out GUIDs */
    getPlayers(subset = ["all"]) {
        return this.rcon
            .createCommand("admin.listPlayers", ...subset)
            .format(this.parseClientList()).send()
            .then(players => {
            return players.map(p => {
                if (typeof p.ip === "string")
                    return p;
                p.ip = this.pbAddressCache[p.name];
                return p;
            });
        });
    }
    /** Disconnect from server */
    quit() {
        return this.rcon.stop();
    }
    /** retrieves basic serverinformations */
    serverInfo() {
        return this.createCommand("serverinfo")
            .format(words => ({
            name: words.shift().toString(),
            slots: words.shift().toNumber(),
            totalSlots: words.shift().toNumber(),
            mode: words.shift().toString(),
            map: words.shift().toString(),
            roundsPlayed: words.shift().toNumber(),
            roundsTotal: words.shift().toNumber(),
            ...this.getScores(words),
            onlineState: words.shift().toString(),
            ranked: words.shift().toBoolean(),
            punkBuster: words.shift().toBoolean(),
            password: words.shift().toBoolean(),
            uptime: words.shift().toNumber(),
            roundTime: words.shift().toNumber(),
            address: words.shift().toString(),
            punkBusterVersion: words.shift().toString(),
            joinQueueEnabled: words.shift().toBoolean(),
            region: words.shift().toString(),
            closesPingSite: words.shift().toString(),
            country: words.shift().toString(),
            matchmaking: words.shift().toBoolean()
        }))
            .send();
    }
    /** gets the amount of players a server can have */
    effectiveMaxPlayers() {
        return this.createCommand("admin.effectiveMaxPlayers").format(([w]) => w.toNumber()).send();
    }
    /**
     * gets the idle duration of a specific client in seconds
     * @param name name of the player to retrieve idle duration for
     */
    idleDuration(name) {
        return this.createCommand("player.idleDuration", name).format(([w]) => w.toNumber()).send();
    }
    /**
     * checks wether a client is dead or alive
     * @param name name of the player to check
     */
    playerAlive(name) {
        return this.createCommand("player.isAlive", name).format(([w]) => w.toBoolean()).send();
    }
    /**
     * Kick player <soldier name> from server
     * @param name player name to kick
     * @param reason kick reason
     */
    playerKick(name, reason) {
        return this.createCommand("admin.kickPlayer", name, reason).send();
    }
    /**
     * Move a player to another team and/or squad
     * Only works if player is dead. This command will kill player if forceKill is true
     * @param name player name to move
     * @param teamId
     * @param squadId
     * @param forceKill kill the player to move?
     */
    playerMove(name, teamId, squadId, forceKill) {
        return this.createCommand("admin.movePlayer", name, teamId, squadId, forceKill).send();
    }
    /**
     * Kill a player without any stats effect
     * @param name
     */
    playerKill(name) {
        return this.createCommand("admin.killPlayer", name).send();
    }
    /**
     * returns the players ping
     * @param name name of the player to check
     */
    playerPing(name) {
        return this.createCommand("player.ping", name).format(([w]) => w.toBoolean()).send();
    }
    /** Query whether the PunkBuster server module is active */
    punkBusterActive() {
        return this.createCommand("punkBuster.isActive").format(([w]) => w.toBoolean()).send();
    }
    /** Attempt to activate PunkBuster server module if it currently is inactive */
    punkBusterActivate() {
        return this.createCommand("punkBuster.active").send();
    }
    /**
     * Send a raw PunkBuster command to the PunkBuster server
     * @param cmd command to send
     */
    punkBusterSendCommand(cmd) {
        return this.createCommand("punkBuster.pb_sv_command", cmd).send();
    }
    /**
     * Send a chat message to players. The message must be less than 128 characters long.
     * @param msg message to send
     * @param subset subset to send message to
     */
    say(msg, subset) {
        return this.createCommand("admin.say", msg, ...subset).send();
    }
    /** Retrieves a single player by its name */
    getPlayerByName(name) {
        return this.getPlayers().then(players => players.find(p => p.name === name));
    }
    /** retrieves multiple players by their name */
    async getPlayersByName(names) {
        const ns = Array.isArray(names) ? names = Object.fromEntries(names.map(n => [n, n])) : names;
        let players = await this.getPlayers();
        players = players.filter(p => Object.values(ns).includes(p.name));
        return Object.fromEntries(Object.keys(ns).map(n => [n, players.find(p => p.name === ns[n])]));
    }
    /**
     * Show an obnoxious message on players’ screens for the specified duration.
     * If duration is left out, a default of 10 seconds is assumed.
     * If players are left out, the message will go to all players.
     * The message must be less than 256 characters long.
     * @param msg message to send
     * @param duration duration in seconds to display the message
     * @param subset subset to send message to
     */
    yell(msg, duration, subset = []) {
        return this.createCommand("admin.yell", msg, duration, ...subset).send();
    }
    /** Load list of VIP players from file */
    loadReservedSlots() {
        return this.createCommand("reservedSlotsList.load").send();
    }
    /** Save list of VIP players from file */
    saveReservedSlots() {
        return this.createCommand("reservedSlotsList.save").send();
    }
    /**
     * Add player to VIP list
     * @param name player to add
     * @param save save the list
     */
    addReservedSlot(name, save = true) {
        return this.createCommand("reservedSlotsList.add", name).send()
            .then(() => save ? this.saveReservedSlots() : []);
    }
    /**
     * Remove a player from the VIP list
     * @param name player to remove
     * @param id
     */
    delReservedSlot(name, save = true) {
        return this.createCommand("reservedSlotsList.remove", name).send()
            .then(() => save ? this.saveReservedSlots() : []);
    }
    /** clears VIP list */
    clearReservedSlots(save = true) {
        return this.createCommand("reservedSlotsList.clear").send()
            .then(() => save ? this.saveReservedSlots() : []);
    }
    /** return a section of the list of VIP players’ name */
    getReservedSlots(offset) {
        return this.createCommand("reservedSlotsList.list", offset).send();
    }
    /**
     * enable or disable aggressive join
     * @param enable wether it should be enabled or not
     */
    aggressiveJoin(enable) {
        return this.createCommand("reservedSlotsList.aggressiveJoin", enable).send();
    }
    /** load list of banned players/IPs/GUIDs from file */
    loadBans() {
        return this.createCommand("banList.load").send();
    }
    /** save list of banned players/IPs/GUIDs to file */
    saveBans() {
        return this.createCommand("banList.save").send();
    }
    /** retrieve the banlist */
    getBans() {
        return this.createCommand("banList.list")
            .format(words => {
            return words.reduce((acc, curr, index) => {
                const current = () => acc[acc.length - 1];
                switch (index % 6) {
                    case 0:
                        acc.push({});
                        current().subset = [curr.toString()];
                        return acc;
                    case 1: return (current().subset.push(curr.toString()), acc);
                    case 2: return (current().timeout = [curr.toString()], acc);
                    case 3: return (current().timeout.push(curr.toNumber()), acc);
                    case 4: return (current().unknown = curr.toString(), acc);
                    case 5: return (current().reason = curr.toString(), acc);
                }
            }, []);
        })
            .send();
    }
    /**
     * adding a new name/IP/GUID ban will replace any previous ban for that name/IP/GUID
     * @param type define wether its a guid, ip or name
     * @param id
     * @param timeout
     * @param reason displayed ban reason
     * @param save save the list
     */
    addBan(type, timeout, reason, save = true) {
        return this.createCommand("banList.add", ...type, ...timeout, reason).send()
            .then(() => save ? this.saveBans() : []);
    }
    /**
     * Remove name/ip/guid from banlist
     * @param type id type to remove
     * @param save save the list
     */
    delBan(type, save = true) {
        return this.createCommand("banList.remove", ...type).send()
            .then(() => save ? this.saveBans() : []);
    }
    /** clears ban list */
    clearBanList(save = true) {
        return this.createCommand("banList.clear").send()
            .then(() => save ? this.saveBans() : []);
    }
    /** clears the map list and loads it from disk again */
    loadMaps() {
        return this.createCommand("mapList.load").send();
    }
    /** saves the maplist to disk */
    saveMaps() {
        return this.createCommand("mapList.save").send();
    }
    /**
     * Adds the map <map>, with gamemode <gamemode>, for <rounds> rounds, to the
     * maplist. If <index> is not specified, it is appended to the end; otherwise, it is inserted
     * before the map which is currently at position <index>.
     * @param map
     * @param mode
     * @param rounds
     * @param index
     */
    addMap(map, mode, rounds = 2, index, save = true) {
        return this.createCommand("mapList.add", map, mode, rounds, index).send()
            .then(() => save ? this.saveMaps() : []);
    }
    /**
     * Removes the map at offset <index> from the maplist
     * @param index
     */
    delMap(index, save = true) {
        return this.createCommand("mapList.remove", index).send()
            .then(() => save ? this.saveMaps() : []);
    }
    /** clears the map list */
    clearMaps(save = true) {
        return this.createCommand("mapList.clear").send()
            .then(() => save ? this.saveMaps() : []);
    }
    /**
     * Returns a section of the map list.
     * At most 100 entries will be returned by the command.
     * To retrieve the full list, perform several mapList.list calls with increasing offset until the
     * server returns 0 entries.
     * (There is an unsolved synchronization problem hidden there: if the map list is edited by another
     * RCON client during this process, then entries may be missed during retrieval. There is no
     * known workaround for this.)
     * @param offset
     */
    getMaps(offset) {
        return this.createCommand("mapList.list", offset)
            .format(w => {
            return w.slice(2).reduce((acc, _, i, arr) => {
                if (i % 3 !== 0)
                    return acc;
                return [...acc, {
                        map: arr[i].toString(),
                        mode: arr[i + 1].toString(),
                        rounds: arr[i + 2].toNumber(),
                        index: (offset || 0) + i / 3
                    }];
            }, []);
        })
            .send();
    }
    /**
     * Specifies which map to switch to once the current round completes. If there are rounds remaining
     * on the current map, those rounds will be skipped.
     * @param index
     */
    setNextMapIndex(index) {
        return this.createCommand("mapList.setNextMapIndex", index).send();
    }
    /** returns the index of the map that is currently being played, and the index of the next map to run. */
    getMapIndices() {
        return this.createCommand("mapList.getMapIndices")
            .format(w => ({ index: w[0].toNumber(), next: w[1].toNumber() }))
            .send();
    }
    /** switches immediately to the next round, without going through the end-of-round sequence. */
    nextRound() {
        return this.createCommand("mapList.runNextRound").send();
    }
    /** restarts the current round, without going through the end of round sequence */
    restartRound() {
        return this.createCommand("mapList.restartRound").send();
    }
    /**
     * Lists the mods to load on the next server restart.
     * This basically lists all mods present in the ModList.txt file
     * and may not be the same as the list of mods that are currently running.
     */
    getMods() {
        return this.createCommand("modList.List").send();
    }
    /** lists the mods that are available to be added to the mod list */
    getAvailableMods() {
        return this.createCommand("modList.Available").send();
    }
    /**
     * Removes a mod from the list of mods to load on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not unload any currently running mods.
     * @param name name of the mod to remove
     */
    delMod(name) {
        return this.createCommand("modList.Remove", name).send();
    }
    /**
     * Adds a mod to the list of mods to load on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not load the mod immediately.
     * @param name name of the mod to add
     */
    addMod(name) {
        return this.createCommand("modList.Add", name).send();
    }
    /**
     * Clears the list of mods to loads on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not unload any currently running mods.
     */
    clearMods() {
        return this.createCommand("modList.Clear").send();
    }
    /**
     * Lists all currently loaded / running mods.
     */
    getRunningMods() {
        return this.createCommand("modList.ListRunning").send();
    }
    /**
     * reloads all currently loaded mods.
     * keep in mind that this can cause significant server and client lag
     * and also crashes as not all mods support reloading
     */
    reloadExtensions() {
        return this.createCommand("modList.ReloadExtensions").send();
    }
    /**
     * accepts a single boolean argument (true or false) which toggles debug mode for any loaded extensions
     * when set to true, any scripts will be built with debug symbols enabled,
     * which will make it so errors printed on the server and the clients will
     * contain more useful information about their source.
     */
    debugExtensions(toggle) {
        return this.createCommand("modList.Debug", toggle).send();
    }
    /**
     * dnd the current round, declaring <winner> as the winning team
     */
    endRound(winner) {
        return this.createCommand("mapList.endRound", winner).send();
    }
    /**
     * returns the (1-based) current round number, and total number of rounds before switching map.
     */
    getRounds() {
        return this.createCommand("mapList.getRounds")
            .format(w => ({ current: w[0].toNumber(), total: w[1].toNumber() }))
            .send();
    }
    getScores(words) {
        return {
            scores: (() => {
                if (isNaN(words[0].toNumber()))
                    return [];
                return new Array(words.shift().toNumber()).fill(0).map(() => words.shift().toNumber());
            })(),
            targetScore: (() => {
                if (isNaN(words[0].toNumber()))
                    return 0;
                return words.shift().toNumber();
            })()
        };
    }
    parseClientList() {
        return this.parseList((word, name) => {
            switch (name) {
                case "name": return word.toString();
                case "teamId": return word.toNumber();
                case "guid": return word.toString();
                case "playerGuid": return word.toString();
                case "spectator": return word.toBoolean();
                case "squadId": return word.toNumber();
                case "kills": return word.toNumber();
                case "deaths": return word.toNumber();
                case "score": return word.toNumber();
                case "rank": return word.toString();
                case "ping": return word.toNumber();
                case "ip": return word.toString();
                default: return word.toString();
            }
        });
    }
    parseList(cb, replace = {}) {
        return (words) => {
            const entries = words[0].toNumber();
            const names = words.slice(1, entries + 1)
                .map(w => w.toString())
                .map(s => Object.keys(replace).includes(s) ? replace[s] : s);
            return words.slice(entries + 2).reduce((acc, curr, i) => {
                const index = i % entries;
                if (index === 0)
                    acc.push({});
                const name = names[index];
                if (name === Battlefield.ParseListReplaceOption.OMIT)
                    return acc;
                //@ts-ignore
                if (index === 0)
                    acc[acc.length - 1][name] = curr.toNumber();
                //@ts-ignore
                acc[acc.length - 1][name] = cb(curr, name);
                return acc;
            }, []);
        };
    }
}
exports.Battlefield = Battlefield;
(function (Battlefield) {
    let ParseListReplaceOption;
    (function (ParseListReplaceOption) {
        ParseListReplaceOption[ParseListReplaceOption["OMIT"] = 0] = "OMIT";
    })(ParseListReplaceOption = Battlefield.ParseListReplaceOption || (Battlefield.ParseListReplaceOption = {}));
    let Version;
    (function (Version) {
        Version[Version["UNKNOWN"] = 0] = "UNKNOWN";
        Version["BF3"] = "BF3";
        Version["VU"] = "";
    })(Version = Battlefield.Version || (Battlefield.Version = {}));
    let Squad;
    (function (Squad) {
        Squad[Squad["NONE"] = 0] = "NONE";
        Squad[Squad["ALPHA"] = 1] = "ALPHA";
        Squad[Squad["BRAVO"] = 2] = "BRAVO";
        Squad[Squad["CHARLIE"] = 3] = "CHARLIE";
        Squad[Squad["DELTA"] = 4] = "DELTA";
        Squad[Squad["ECHO"] = 5] = "ECHO";
        Squad[Squad["FOXTROT"] = 6] = "FOXTROT";
        Squad[Squad["GOLF"] = 7] = "GOLF";
        Squad[Squad["HOTEL"] = 8] = "HOTEL";
        Squad[Squad["INDIA"] = 9] = "INDIA";
        Squad[Squad["JULIET"] = 10] = "JULIET";
        Squad[Squad["KILO"] = 11] = "KILO";
        Squad[Squad["LIMA"] = 12] = "LIMA";
        Squad[Squad["MIKE"] = 13] = "MIKE";
        Squad[Squad["NOVEMBER"] = 14] = "NOVEMBER";
        Squad[Squad["OSCAR"] = 15] = "OSCAR";
        Squad[Squad["PAPA"] = 16] = "PAPA";
        Squad[Squad["QUEBEC"] = 17] = "QUEBEC";
        Squad[Squad["ROMEO"] = 18] = "ROMEO";
        Squad[Squad["SIERRA"] = 19] = "SIERRA";
        Squad[Squad["TANGO"] = 20] = "TANGO";
        Squad[Squad["UNIFORM"] = 21] = "UNIFORM";
        Squad[Squad["VICTOR"] = 22] = "VICTOR";
        Squad[Squad["WHISKEY"] = 23] = "WHISKEY";
        Squad[Squad["XRAY"] = 24] = "XRAY";
        Squad[Squad["YANKEE"] = 25] = "YANKEE";
        Squad[Squad["ZULU"] = 26] = "ZULU";
        Squad[Squad["HAGGARD"] = 27] = "HAGGARD";
        Squad[Squad["SWEETWATER"] = 28] = "SWEETWATER";
        Squad[Squad["PRESTON"] = 29] = "PRESTON";
        Squad[Squad["REDFORD"] = 30] = "REDFORD";
        Squad[Squad["FAITH"] = 31] = "FAITH";
        Squad[Squad["CELESTE"] = 32] = "CELESTE";
    })(Squad = Battlefield.Squad || (Battlefield.Squad = {}));
})(Battlefield = exports.Battlefield || (exports.Battlefield = {}));
//# sourceMappingURL=Battlefield.js.map