/// <reference types="node" />
import { Request } from "./Request";
import { Word } from "./protocol/Word";
import { EventEmitter } from "events";
export declare class Rcon extends EventEmitter {
    private socket;
    private options;
    private sequence?;
    private pending;
    private queued;
    private waitForPriorized;
    private buffer;
    constructor(options: Rcon.ConnectionOptions);
    /**
     * connects to the socket
     * @param host hostname to connect to
     * @param port port to connect to
     */
    connect(): Promise<unknown>;
    /**
     * push all pending sequences back to queued
     * after a successfull reconnect all queued packets get resent
     */
    private onClose;
    private onData;
    private handlePacket;
    private handleEvent;
    createCommand<T = string[]>(cmd: string, ...args: Rcon.Argument[]): Request<T>;
    /**
     * sends a request, either writes it to the socket
     * or pushes it to queue if its currently not writeable
     * @param req
     */
    private sendRequest;
    /**
     * continues with queued items
     * handles priorized items one after one
     */
    private continueWithQueue;
    write(buffer: Buffer): Promise<unknown>;
    stop(): void;
    private getNextSequence;
    private wrapInPacket;
    static toStrings(args: Rcon.Argument[]): string[];
}
export declare namespace Rcon {
    interface ConnectionOptions {
        host: string;
        port: number;
        eventHandler: eventHandler;
    }
    type eventHandler = (event: string, words: Word[]) => void;
    type Argument = boolean | string | number | undefined;
    type Pending = Request<any>[];
    type Queued = Request<any>[];
}
//# sourceMappingURL=Rcon.d.ts.map