"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rcon = void 0;
const net_1 = __importDefault(require("net"));
const Sequence_1 = require("./protocol/Sequence");
const Packet_1 = require("./protocol/Packet");
const Request_1 = require("./Request");
const events_1 = require("events");
class Rcon extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.pending = [];
        this.queued = [];
        this.waitForPriorized = false;
        this.buffer = Buffer.alloc(0);
        this.options = options;
    }
    /**
     * connects to the socket
     * @param host hostname to connect to
     * @param port port to connect to
     */
    connect() {
        return new Promise((fulfill, reject) => {
            if (this.socket && !this.socket.destroyed)
                return reject(new Error("already connected to rcon"));
            if (this.socket)
                this.socket.removeAllListeners();
            this.socket = net_1.default.connect({
                host: this.options.host,
                port: this.options.port,
            });
            const handler = async (err) => {
                this.socket.removeListener("error", handler);
                this.socket.removeListener("connect", handler);
                if (err instanceof Error)
                    return reject(err);
                await fulfill();
                this.continueWithQueue();
                this.socket.on("close", this.onClose.bind(this));
                this.socket.on("data", this.onData.bind(this));
            };
            this.socket.on("error", handler);
            this.socket.on("connect", handler);
        });
    }
    /**
     * push all pending sequences back to queued
     * after a successfull reconnect all queued packets get resent
     */
    onClose() {
        this.pending.forEach(req => this.queued.unshift(req));
        this.pending = [];
        this.emit("close");
    }
    onData(buffer) {
        const { buffers, remainder } = Packet_1.Packet.getPacketBuffers(Buffer.concat([this.buffer, buffer]));
        this.buffer = remainder;
        buffers.forEach(buffer => this.handlePacket(buffer));
    }
    handlePacket(buffer) {
        const packet = Packet_1.Packet.from(buffer);
        const request = this.pending.find(p => p.sequenceNumber === packet.sequence.sequence);
        if (!request)
            return this.handleEvent(packet);
        this.pending.splice(this.pending.indexOf(request), 1);
        if (this.pending.length === 0 && this.waitForPriorized) {
            this.waitForPriorized = false;
            this.continueWithQueue();
        }
        request.setResponse(packet);
    }
    handleEvent(packet) {
        this.options.eventHandler(packet.words[0].toString(), packet.words.slice(1));
    }
    createCommand(cmd, ...args) {
        let request;
        const packet = this.wrapInPacket([cmd, ...Rcon.toStrings(args)]);
        request = new Request_1.Request({ packet, send: this.sendRequest.bind(this) });
        return request;
    }
    /**
     * sends a request, either writes it to the socket
     * or pushes it to queue if its currently not writeable
     * @param req
     */
    sendRequest(req, force = false) {
        if (!this.socket || !this.socket.writable || (this.waitForPriorized && !force)) {
            this.queued.push(req);
        }
        else {
            if (req.priorized)
                this.waitForPriorized = true;
            this.pending.push(req);
            this.write(req.packet.toBuffer());
        }
    }
    /**
     * continues with queued items
     * handles priorized items one after one
     */
    continueWithQueue() {
        const queued = [...this.queued];
        this.queued = [];
        const prio = queued.filter(r => r.priorized);
        if (prio.length > 0) {
            const request = prio.shift();
            this.queued = [...prio, ...queued.filter(r => !r.priorized)];
            this.sendRequest(request, true);
        }
        else {
            queued.forEach(r => this.sendRequest(r));
        }
    }
    write(buffer) {
        return new Promise((fulfill, reject) => {
            this.socket.write(buffer, err => {
                if (err)
                    return reject(err);
                fulfill();
            });
        });
    }
    stop() {
        return this.socket.destroy();
    }
    getNextSequence(opts) {
        if (this.sequence) {
            this.sequence = this.sequence.nextSequence(opts);
        }
        else {
            this.sequence = new Sequence_1.Sequence({ sequence: 0, ...opts });
        }
        return this.sequence;
    }
    wrapInPacket(words) {
        return new Packet_1.Packet({
            words,
            sequence: this.getNextSequence({
                origin: Sequence_1.Sequence.Origin.CLIENT,
                type: Sequence_1.Sequence.Type.REQUEST
            })
        });
    }
    static toStrings(args) {
        return args
            .filter(arg => arg !== undefined)
            .map((arg) => {
            switch (typeof arg) {
                case "number":
                    return arg.toString();
                case "boolean":
                    return arg === true ? "true" : "false";
                case "string":
                default:
                    return arg;
            }
        });
    }
}
exports.Rcon = Rcon;
//# sourceMappingURL=Rcon.js.map