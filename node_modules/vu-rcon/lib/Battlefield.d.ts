/// <reference types="node" />
import * as Event from "./types/Event";
import { EventEmitter } from "events";
import { Variable } from "./Variable";
export interface Battlefield {
    on(event: "close", handler: (err: Error | undefined) => void): this;
    on(event: "ready", handler: () => void): this;
    on(event: "chat", handler: (data: Event.PlayerOnChat) => void): this;
    on(event: "spawn", handler: (data: Event.PlayerOnSpawn) => void): this;
    on(event: "kill", handler: (data: Event.PlayerOnKill) => void): this;
    on(event: "punkbuster", handler: (data: Event.PunkBuster) => void): this;
    on(event: "playerAuthenticated", handler: (data: Event.OnAuthenticated) => void): this;
    on(event: "playerJoin", handler: (data: Event.OnJoining) => void): this;
    on(event: "playerLeave", handler: (data: Event.OnLeave) => void): this;
    on(event: "teamChange", handler: (data: Event.OnTeamChange) => void): this;
    on(event: "squadChange", handler: (data: Event.OnSquadChange) => void): this;
    on(event: "maxPlayerCountChange", handler: (data: Event.MaxPlayerCountChange) => void): this;
    on(event: "levelLoaded", handler: (data: Event.MaxPlayerCountChange) => void): this;
    on(event: "roundOver", handler: (data: Event.OnRoundOver) => void): this;
    on(event: "roundOverPlayers", handler: (data: Event.OnRoundOver) => void): this;
    on(event: "roundOverTeamScores", handler: (data: Event.OnRoundOverTeamScores) => void): this;
    on(event: "event", handler: (data: Event.OnUnhandled) => void): this;
    on(event: "request", handler: (data: Event.OnRequestCreate) => void): this;
}
export declare class Battlefield extends EventEmitter {
    readonly options: Battlefield.Options;
    private rcon;
    private rconError?;
    private pbAddressCache;
    version: {
        game: Battlefield.Version;
        version: number;
    };
    readonly vu: Variable<Battlefield.VuVariable>;
    readonly var: Variable<Battlefield.Variables>;
    constructor(options: Battlefield.Options);
    /**
     * tests an rcon connection and disconnects after
     */
    static testConnection(options: Omit<Battlefield.Options, "autoconnect">): Promise<true | Error>;
    /**
     * creates a new Battlefield instance
     * @param options
     */
    static connect(options: Omit<Battlefield.Options, "autoconnect">): Promise<Battlefield>;
    /** connects and initializes the query */
    connect(): Promise<this>;
    /** initializes the connection */
    private initialize;
    /**
     * sleeps a certain time
     * @param time
     */
    static sleep(time: number): Promise<unknown>;
    /**
     * attempts to reconnects to the battlefield server
     * @param maxAttempts number of tries <= 0 tries to connect forever
     * @param timeout timeout in ms between connection attempts
     */
    reconnect(maxAttempts?: number, timeout?: number): Promise<this>;
    private eventHandler;
    private onRoundOverTeamScores;
    private onRoundOverPlayers;
    private onRoundOver;
    private onLevelLoaded;
    private onMaxPlayerCountChange;
    private playerOnLeave;
    private onSquadChange;
    private onTeamChange;
    private onAuthenticated;
    private onJoin;
    private onPunkBuster;
    private playerOnKill;
    private playerOnSpawn;
    private playerOnChat;
    private createCommand;
    /** sends the help command to the server */
    help(): Promise<unknown>;
    /**
     * Set whether or not the server will send events to the current connection
     * @param set enable or disable events
     */
    enableEvents(set: boolean): Promise<unknown>;
    /** Game server type and build ID uniquely identify the server, and the protocol it is running. */
    private fetchVersion;
    /** get the battlefield server salt */
    private getSalt;
    /** creates the hashed password from the actual password and the hash */
    private getPasswordHash;
    /**
     * Securely logs you in with a hashed password
     * @param password password to login with
     */
    login(password: string): Promise<string[]>;
    /** Logout from game server */
    logout(): Promise<unknown>;
    /** return list of all players on the server, but with zeroed out GUIDs */
    getPlayers(subset?: Battlefield.PlayerSubset): Promise<Battlefield.Player[]>;
    /** Disconnect from server */
    quit(): void;
    /** retrieves basic serverinformations */
    serverInfo(): Promise<Battlefield.ServerInfo>;
    /** gets the amount of players a server can have */
    effectiveMaxPlayers(): Promise<number>;
    /**
     * gets the idle duration of a specific client in seconds
     * @param name name of the player to retrieve idle duration for
     */
    idleDuration(name: string): Promise<number>;
    /**
     * checks wether a client is dead or alive
     * @param name name of the player to check
     */
    playerAlive(name: string): Promise<boolean>;
    /**
     * Kick player <soldier name> from server
     * @param name player name to kick
     * @param reason kick reason
     */
    playerKick(name: string, reason?: string): Promise<unknown>;
    /**
     * Move a player to another team and/or squad
     * Only works if player is dead. This command will kill player if forceKill is true
     * @param name player name to move
     * @param teamId
     * @param squadId
     * @param forceKill kill the player to move?
     */
    playerMove(name: string, teamId: number, squadId: number, forceKill: boolean): Promise<unknown>;
    /**
     * Kill a player without any stats effect
     * @param name
     */
    playerKill(name: string): Promise<unknown>;
    /**
     * returns the players ping
     * @param name name of the player to check
     */
    playerPing(name: string): Promise<boolean>;
    /** Query whether the PunkBuster server module is active */
    punkBusterActive(): Promise<boolean>;
    /** Attempt to activate PunkBuster server module if it currently is inactive */
    punkBusterActivate(): Promise<unknown>;
    /**
     * Send a raw PunkBuster command to the PunkBuster server
     * @param cmd command to send
     */
    punkBusterSendCommand(cmd: string): Promise<unknown>;
    /**
     * Send a chat message to players. The message must be less than 128 characters long.
     * @param msg message to send
     * @param subset subset to send message to
     */
    say(msg: string, subset: string[]): Promise<unknown>;
    /** Retrieves a single player by its name */
    getPlayerByName(name: string): Promise<Battlefield.Player | undefined>;
    /** retrieves multiple players by their name */
    getPlayersByName(names: string[] | Record<string, string>): Promise<{
        [k: string]: Battlefield.Player | undefined;
    }>;
    /**
     * Show an obnoxious message on players’ screens for the specified duration.
     * If duration is left out, a default of 10 seconds is assumed.
     * If players are left out, the message will go to all players.
     * The message must be less than 256 characters long.
     * @param msg message to send
     * @param duration duration in seconds to display the message
     * @param subset subset to send message to
     */
    yell(msg: string, duration?: number, subset?: string[]): Promise<unknown>;
    /** Load list of VIP players from file */
    loadReservedSlots(): Promise<unknown>;
    /** Save list of VIP players from file */
    saveReservedSlots(): Promise<unknown>;
    /**
     * Add player to VIP list
     * @param name player to add
     * @param save save the list
     */
    addReservedSlot(name: string, save?: boolean): Promise<unknown>;
    /**
     * Remove a player from the VIP list
     * @param name player to remove
     * @param id
     */
    delReservedSlot(name: string, save?: boolean): Promise<unknown>;
    /** clears VIP list */
    clearReservedSlots(save?: boolean): Promise<unknown>;
    /** return a section of the list of VIP players’ name */
    getReservedSlots(offset?: number): Promise<unknown>;
    /**
     * enable or disable aggressive join
     * @param enable wether it should be enabled or not
     */
    aggressiveJoin(enable: boolean): Promise<unknown>;
    /** load list of banned players/IPs/GUIDs from file */
    loadBans(): Promise<unknown>;
    /** save list of banned players/IPs/GUIDs to file */
    saveBans(): Promise<unknown>;
    /** retrieve the banlist */
    getBans(): Promise<Battlefield.BanList>;
    /**
     * adding a new name/IP/GUID ban will replace any previous ban for that name/IP/GUID
     * @param type define wether its a guid, ip or name
     * @param id
     * @param timeout
     * @param reason displayed ban reason
     * @param save save the list
     */
    addBan(type: Battlefield.IdType, timeout: Battlefield.Timeout, reason?: string, save?: boolean): Promise<unknown>;
    /**
     * Remove name/ip/guid from banlist
     * @param type id type to remove
     * @param save save the list
     */
    delBan(type: string[], save?: boolean): Promise<unknown>;
    /** clears ban list */
    clearBanList(save?: boolean): Promise<unknown>;
    /** clears the map list and loads it from disk again */
    loadMaps(): Promise<unknown>;
    /** saves the maplist to disk */
    saveMaps(): Promise<unknown>;
    /**
     * Adds the map <map>, with gamemode <gamemode>, for <rounds> rounds, to the
     * maplist. If <index> is not specified, it is appended to the end; otherwise, it is inserted
     * before the map which is currently at position <index>.
     * @param map
     * @param mode
     * @param rounds
     * @param index
     */
    addMap(map: string, mode: string, rounds?: number, index?: number, save?: boolean): Promise<unknown>;
    /**
     * Removes the map at offset <index> from the maplist
     * @param index
     */
    delMap(index: number, save?: boolean): Promise<unknown>;
    /** clears the map list */
    clearMaps(save?: boolean): Promise<unknown>;
    /**
     * Returns a section of the map list.
     * At most 100 entries will be returned by the command.
     * To retrieve the full list, perform several mapList.list calls with increasing offset until the
     * server returns 0 entries.
     * (There is an unsolved synchronization problem hidden there: if the map list is edited by another
     * RCON client during this process, then entries may be missed during retrieval. There is no
     * known workaround for this.)
     * @param offset
     */
    getMaps(offset?: number): Promise<Battlefield.MapList>;
    /**
     * Specifies which map to switch to once the current round completes. If there are rounds remaining
     * on the current map, those rounds will be skipped.
     * @param index
     */
    setNextMapIndex(index: number): Promise<unknown>;
    /** returns the index of the map that is currently being played, and the index of the next map to run. */
    getMapIndices(): Promise<{
        index: number;
        next: number;
    }>;
    /** switches immediately to the next round, without going through the end-of-round sequence. */
    nextRound(): Promise<unknown>;
    /** restarts the current round, without going through the end of round sequence */
    restartRound(): Promise<unknown>;
    /**
     * Lists the mods to load on the next server restart.
     * This basically lists all mods present in the ModList.txt file
     * and may not be the same as the list of mods that are currently running.
     */
    getMods(): Promise<string[]>;
    /** lists the mods that are available to be added to the mod list */
    getAvailableMods(): Promise<string[]>;
    /**
     * Removes a mod from the list of mods to load on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not unload any currently running mods.
     * @param name name of the mod to remove
     */
    delMod(name: string): Promise<unknown>;
    /**
     * Adds a mod to the list of mods to load on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not load the mod immediately.
     * @param name name of the mod to add
     */
    addMod(name: string): Promise<unknown>;
    /**
     * Clears the list of mods to loads on the next server restart
     * and saves the changes to the ModList.txt file.
     * This will not unload any currently running mods.
     */
    clearMods(): Promise<unknown>;
    /**
     * Lists all currently loaded / running mods.
     */
    getRunningMods(): Promise<string[]>;
    /**
     * reloads all currently loaded mods.
     * keep in mind that this can cause significant server and client lag
     * and also crashes as not all mods support reloading
     */
    reloadExtensions(): Promise<unknown>;
    /**
     * accepts a single boolean argument (true or false) which toggles debug mode for any loaded extensions
     * when set to true, any scripts will be built with debug symbols enabled,
     * which will make it so errors printed on the server and the clients will
     * contain more useful information about their source.
     */
    debugExtensions(toggle: boolean): Promise<unknown>;
    /**
     * dnd the current round, declaring <winner> as the winning team
     */
    endRound(winner: number): Promise<unknown>;
    /**
     * returns the (1-based) current round number, and total number of rounds before switching map.
     */
    getRounds(): Promise<{
        current: number;
        total: number;
    }>;
    private getScores;
    private parseClientList;
    private parseList;
}
export declare namespace Battlefield {
    interface Options {
        host: string;
        port: number;
        password: string;
        autoconnect?: boolean;
    }
    enum ParseListReplaceOption {
        OMIT = 0
    }
    enum Version {
        UNKNOWN = 0,
        BF3 = "BF3",
        VU = ""
    }
    type MapList = MapEntry[];
    interface MapEntry {
        map: string;
        mode: string;
        rounds: number;
        index: number;
    }
    interface ServerInfo {
        name: string;
        slots: number;
        totalSlots: number;
        mode: string;
        map: string;
        roundsPlayed: number;
        roundsTotal: number;
        scores: number[];
        targetScore: number;
        onlineState: string;
        ranked: boolean;
        punkBuster: boolean;
        password: boolean;
        uptime: number;
        roundTime: number;
        address: string;
        punkBusterVersion: string;
        joinQueueEnabled: boolean;
        region: string;
        closesPingSite: string;
        country: string;
        matchmaking: boolean;
    }
    enum Squad {
        NONE = 0,
        ALPHA = 1,
        BRAVO = 2,
        CHARLIE = 3,
        DELTA = 4,
        ECHO = 5,
        FOXTROT = 6,
        GOLF = 7,
        HOTEL = 8,
        INDIA = 9,
        JULIET = 10,
        KILO = 11,
        LIMA = 12,
        MIKE = 13,
        NOVEMBER = 14,
        OSCAR = 15,
        PAPA = 16,
        QUEBEC = 17,
        ROMEO = 18,
        SIERRA = 19,
        TANGO = 20,
        UNIFORM = 21,
        VICTOR = 22,
        WHISKEY = 23,
        XRAY = 24,
        YANKEE = 25,
        ZULU = 26,
        HAGGARD = 27,
        SWEETWATER = 28,
        PRESTON = 29,
        REDFORD = 30,
        FAITH = 31,
        CELESTE = 32
    }
    type Subset = "all" | "team" | "squad" | "player";
    type PlayerSubset = [Subset, (string | number)?];
    type Timeout = ["perm" | "rounds" | "seconds", number?];
    type IdType = ["name" | "ip" | "guid", string];
    type PlayerList = Player[];
    interface Player {
        name: string;
        guid: string;
        teamId: number;
        squadId: number;
        kills: number;
        deaths: number;
        score: number;
        rank: string;
        ping: number;
        playerGuid: string;
        spectator: boolean;
        ip?: string;
    }
    type BanList = BanEntry[];
    interface BanEntry {
        subset: ["ip" | "name" | "guid", string];
        timeout: ["perm" | "seconds" | "rounds", number];
        unknown: string;
        reason: string;
    }
    interface VuVariable extends Variable.List {
        DestructionEnabled: boolean;
        SuppressionMultiplier: number;
        DesertingAllowed: boolean;
        VehicleDisablingEnabled: boolean;
        HighPerformanceReplication: boolean;
        SetTeamTicketCount: [number, number];
        FrequencyMode: string;
        SpectatorCount: number;
        FadeOutAll: void;
        FadeInAll: void;
    }
    interface Variables extends Variable.List {
        ranked: boolean;
        serverName: string;
        gamePassword: string;
        autoBalance: boolean;
        friendlyFire: boolean;
        maxPlayers: number;
        serverDescription: string;
        serverMessage: string;
        killCam: boolean;
        miniMap: boolean;
        hud: boolean;
        crossHair: boolean;
        "3dSpotting": boolean;
        miniMapSpotting: boolean;
        nametag: boolean;
        "3pCam": boolean;
        regenerateHealth: boolean;
        teamKillCountForKick: number;
        teamKillValueForKick: number;
        teamKillValueIncrease: number;
        teamKillValueDecreasePerSecond: number;
        teamKillKickForBan: number;
        idleTimeout: number;
        idleBanRounds: number;
        roundStartPlayerCount: number;
        roundRestartPlayerCount: number;
        roundLockdownCountdown: number;
        vehicleSpawnAllowed: number;
        vehicleSpawnDelay: number;
        soldierHealth: number;
        playerRespawnTime: number;
        playerManDownTime: number;
        bulletDamage: number;
        gameModeCounter: number;
        onlySquadLeaderSpawn: boolean;
        unlockMode: string | "stats";
        premiumStatus: boolean;
        /** set what weapons preset to use when playing the gun master game mode */
        gunMasterWeaponsPreset: number;
    }
}
//# sourceMappingURL=Battlefield.d.ts.map